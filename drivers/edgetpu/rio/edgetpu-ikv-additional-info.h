/* SPDX-License-Identifier: GPL-2.0-only */
/*
 * The protocol of the additional_info between the kernel driver and the firmware.
 * Its implementation will be replaced with litebuf in the future.
 *
 * Copyright (C) 2024 Google LLC
 */

#ifndef __EDGETPU_IKV_ADDITIONAL_INFO_H__
#define __EDGETPU_IKV_ADDITIONAL_INFO_H__

#include <linux/types.h>

#include "edgetpu-internal.h"
#include "edgetpu-iremap-pool.h"

/*
 * TODO(b/301608032): This additional_info must be generated by the litebuf once its C compiler
 * is implemented. Before that we statically define compatible structures here.
 *
 * +--------------------------------------------+ <- 0
 * | struct edgetpu_ikv_additional_info_header  |
 * +--------------------------------------------+ <- root_offset
 * |                                            |  \
 * |                                            |  |
 * | struct edgetpu_ikv_additional_info_root    |  | -> object_size
 * |                                            |  |
 * |                                            |  /
 * +--------------------------------------------+ <- in_fences_offset
 * |                                            |
 * | uint16_t in_fences[in_fences_count]        |
 * |                                            |
 * +--------------------------------------------+ <- out_fences_offset
 * |                                            |
 * | uint16_t out_fences[out_fences_count]      |
 * |                                            |
 * +--------------------------------------------+ <- runtime_data_offset
 * |                                            |
 * |                                            |
 * | uint8_t runtime_data [runtime_data_size]   |
 * |                                            |
 * |                                            |
 * +--------------------------------------------+ <- additional_info_size
 */
struct edgetpu_ikv_additional_info_header {
	/* Unique identifier to differentiate between multiple litebuf schemas. */
	uint8_t identifier;
	/* Unique version within a single schema. */
	uint8_t version;
	/* Reserved for alignment and future use. */
	uint8_t reserved[6];
	/* Offset of the root object. */
	uint64_t root_offset;
} __packed;

struct edgetpu_ikv_additional_info_root {
	/* The total size of this root object in bytes. */
	uint32_t object_size;
	/* The offset of the in_fences vector. */
	int32_t in_fences_offset;
	/* The number of elements in the in_fences vector. */
	uint32_t in_fences_count;
	/* The offset of the out_fences vector. */
	int32_t out_fences_offset;
	/* The number of elements in the out_fences vector. */
	uint32_t out_fences_count;
	/* Runtime specified timeout. */
	uint32_t timeout_ms;
	/* The offset of the runtime defined data buffer. */
	int32_t runtime_data_offset;
	/* The size of the runtime defined data buffer in bytes. */
	uint32_t runtime_data_size;
} __packed;

struct edgetpu_ikv_additional_info {
	/* Header. */
	struct edgetpu_ikv_additional_info_header header;
	/* Root. */
	struct edgetpu_ikv_additional_info_root root;
	/* The pointer to in_fences of VII command ioctl. */
	uint16_t *in_fences;
	/* The pointer to out_fences of VII command ioctl. */
	uint16_t *out_fences;
	/* The pointer to runtime_data of VII command ioctl. */
	uint8_t *runtime_data;
};

/*
 * Fills @info according to the passed additional information. It is expected that the filled @info
 * will be passed to the `edgetpu_ikv_send_cmd` function.
 *
 * Note that the filled @info itself is not compatible to send it to the firmware via litebuf. It is
 * only for the kernel usage. If the user wants to send it to the firmware, they should use the
 * `edgetpu_ikv_additional_info_alloc_and_copy` function below to generate a serialized buffer.
 */
void edgetpu_ikv_additional_info_fill(struct edgetpu_ikv_additional_info *info, uint16_t *in_fences,
				      uint32_t in_fences_count, uint16_t *out_fences,
				      uint32_t out_fences_count, uint32_t timeout_ms,
				      uint8_t *runtime_data, uint32_t runtime_data_size);

/*
 * Allocates a full sized buffer from the MCU data memory pool to @mem and copies serialized @info
 * to there. The buffer will store each component at the right offset to follow the litebuf schema.
 *
 * The caller must release the allocated buffer using `edgetpu_ikv_additional_info_free` function.
 *
 * Returns the size of buffer on success. Otherwise returns a negative errno.
 */
ssize_t edgetpu_ikv_additional_info_alloc_and_copy(struct edgetpu_dev *etdev,
						   struct edgetpu_ikv_additional_info *info,
						   struct edgetpu_coherent_mem *mem);

static inline void edgetpu_ikv_additional_info_free(struct edgetpu_dev *etdev,
						    struct edgetpu_coherent_mem *mem)
{
	edgetpu_iremap_free(etdev, mem);
}

#endif /* __EDGETPU_IKV_ADDITIONAL_INFO_H__ */
